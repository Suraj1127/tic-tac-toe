#!/usr/bin/env python3

"""
Author: Suraj Regmi
Date: 6th August, 2018
Description: AI algorithm, minimax, to solve the tic tac toe problem.
"""
import numpy as np

inf = np.inf
no_of_steps = 0

def get_empty_cells(grid):
    """
    Returns empty cells in list of tuples.
    :param grid: Structure of the board
    :return: List of tuples representing the positions.
    """
    empty_cells = []

    # Loop through the whole board to find empty cells.
    for x, row in enumerate(grid):
        for y, _ in enumerate(row):
            if grid[x][y] == 0:
                empty_cells.append((x, y))
    return empty_cells


def game_score(grid):
    """
    Returns the score of the grid arrangement.
    :param board: Arrangement of the grid.
    :return: 1 if the computer wins, -1 if the human wins and 0 if none wins.
    """

    # -1 is the human, 1 is the computer
    if is_winner(grid, -1):
        return -100
    elif is_winner(grid, 1):
        return 100
    else:
        return 0


def is_winner(grid, player):
    """
    Check if the player wins given the grid arrangement.
    :param board: Arrangement of the grid.
    :param player: Player whose turn is active.
    :return: True if player is wins in the given grid else False
    """

    # states which define win cases
    states = (
        (grid[0][0], grid[0][1], grid[0][2]),
        (grid[1][0], grid[1][1], grid[1][2]),
        (grid[2][0], grid[2][1], grid[2][2]),
        (grid[0][0], grid[1][0], grid[2][0]),
        (grid[0][1], grid[1][1], grid[2][1]),
        (grid[0][2], grid[1][2], grid[2][2]),
        (grid[0][0], grid[1][1], grid[2][2]),
        (grid[2][0], grid[1][1], grid[0][2]),
    )

    # If one of the tuple in states has all elements player, the player wins.
    if (player, player, player) in states:
        return True
    else:
        return False


def is_gameover(grid):
    """
    Returns True if game is over else False.
    :param board: Structure of the grid
    :return: True if game is over else False
    """
    if is_winner(grid, -1) or is_winner(grid, 1) or not len(get_empty_cells(grid)):
        return True
    else:
        return False


def show(grid, move, player=None):
    # Do the move as generated by the AI and print the grid
    grid[move[0]][move[1]] = player
    print(np.array(grid))


def minimax(grid, player, no_of_steps):
    """
    Minimax AI algorithm to find the best move.
    :param grid: the current structure of grid/board where the match is being played
    :param player: player whose turn is the current turn
    :return: best array containing best move and the score of the move.
    """

    # We are maximizing from computer perspective.
    # So, if human makes game the point would be -1.
    # If computer makes game, the point would be +1.
    # If there is draw, the point would be 0.

    # So, the default best score of computer is kept very low value(<-1).
    # And the default best score of human is kept very very high value(>1).
    # We suppose the human as intelligent as the computer is.
    # We try to minimize their score and maximize our score.

    # Note: We are not taking no of steps in consideration as the number of steps
    # in any of the winning cases don't differ by large number.  They might differ
    # by 1/2 steps.  So, that is not taken care of.  In the further releases, that
    # would be looked into hopefully.

    if player == 1:
        # The first and second indices represent indices of the position
        # and the third index represents score of that position.
        best = [-1, -1, -inf]
    else:
        best = [-1, -1, inf]

    # If the game is over, return the score of the grid.
    if is_gameover(grid):
        return [-1, -1, game_score(grid)]

    # Get the unticked/unplayed calls as empty_cells(dtype: array).
    empty_cells = get_empty_cells(grid)

    # Iterate in the empty cells.
    for i in empty_cells:
        # Play move.
        grid[i[0]][i[1]] = player
        no_of_steps += 1

        # Calculate score(best array) by recursively doing
        # depth first search along the possible arrangements.

        # player changes to -player as player changes in each turn.
        score = minimax(grid, -player, no_of_steps+1)

        # This is done to put no of steps into equation too.  This would make the move
        # to win in less number of steps.
        score[2] = score[2] - player*no_of_steps

        # Revert the played move for the depth first search.
        grid[i[0]][i[1]] = 0
        no_of_steps -= 1

        # Save the values of indices to first two indices of score array.
        score[0], score[1] = i[0], i[1]

        # If the player is computer, in order to replace the best by score,
        # the score generated should be greater than the previous stored one.

        # If the player is human, in order to replace the best by score, the
        # score generated should be lesser than the previous stored one as we
        # are minimizing the score of the human.

        if player == 1:
            if score[2] > best[2]:
                best = score
        else:
            if score[2] < best[2]:
                best = score

    return best



def main():

    # Suppose human as -1 and computer as +1 and empty cells as 0
    grid = [
        [1, 0, 0],
        [0, -1, 0],
        [0, -1, 0]
    ]

    # Generate move and do the move.
    move = minimax(grid, +1, 0)

    # Show the grid after playing the generated move.
    show(grid, move, +1)


if __name__ == "__main__":
    main()